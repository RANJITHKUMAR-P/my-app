/* eslint-disable array-callback-return */
/* eslint-disable no-restricted-globals */

// This service worker can be customized!
// See https://developers.google.com/web/tools/workbox/modules
// for the list of available Workbox modules, or add any other
// code you'd like.
// You can also remove this file if you'd prefer not to use a
// service worker, and the Workbox build step will be skipped.

import { clientsClaim } from 'workbox-core'
import { ExpirationPlugin } from 'workbox-expiration'
import { precacheAndRoute, createHandlerBoundToURL } from 'workbox-precaching'
import {
  registerRoute,
  setCatchHandler,
  setDefaultHandler,
} from 'workbox-routing'
import {
  StaleWhileRevalidate,
  CacheFirst,
  NetworkOnly,
} from 'workbox-strategies'
import { CacheableResponsePlugin } from 'workbox-cacheable-response'
import { offlineFallback } from 'workbox-recipes'

const IMAGE_CACHE = 'image-v1'
const MEDIA_CACHE = 'media-v1'
const JS_CACHE = 'js-v1'
const HTML_CACHE = 'html-v1'
const CACHE_VERSION = 'V11694175490' // Set as Version + Unix epoch time
const CACHE_URLS = ['/', '/inplass-storage', '/index.html']

// Precache all of the assets generated by your build process.
// Their URLs are injected into the manifest variable below.
// This variable must be present somewhere in your service worker file,
// even if you decide not to use precaching. See https://cra.link/PWA
const ignored = self.__WB_MANIFEST
console.log(ignored)
setDefaultHandler(new NetworkOnly())
offlineFallback({ pageFallback: '/offline.html' })

// Precache all of the assets generated by your build process.
// Their URLs are injected into the manifest variable below.
// This variable must be present somewhere in your service worker file,
// even if you decide not to use precaching. See https://cra.link/PWA

console.log(ignored)
precacheAndRoute([
  { url: '/index.html', revision: '3' },
  { url: '/offline.html', revision: '3' },
])

clientsClaim()
registerRoute(
  // Return false to exempt requests from being fulfilled by index.html.
  ({ request, url }) => {
    // If this isn't a navigation, skip.
    // If this is a URL that starts with /_, skip.
    // If this looks like a URL for a resource, because it contains // a file extension, skip.

    if (request.mode !== 'navigate' || url.pathname.startsWith('/_'))
      return false

    // Return true to signal that we want to use the handler.
    return true
  },
  createHandlerBoundToURL(process.env.PUBLIC_URL + '/index.html')
)

registerRoute(
  ({ request }) => request.destination === 'image',
  new StaleWhileRevalidate({
    cacheName: IMAGE_CACHE,
    plugins: [
      new ExpirationPlugin({
        maxAgeSeconds: 60 * 60, // 1 hour
        maxEntries: 50,
      }),
    ],
  })
)

registerRoute(
  ({ url }) => url.pathname.startsWith('/static/media/'),
  new CacheFirst({
    cacheName: MEDIA_CACHE,
    plugins: [
      new ExpirationPlugin({
        // Only cache requests for a week
        maxAgeSeconds: 60 * 1, // 15 minutes
        // Only cache 10 requests.
        maxEntries: 50,
      }),
    ],
  })
)

registerRoute(
  ({ url }) => url.pathname.startsWith('/static/js/'),
  new StaleWhileRevalidate({
    cacheName: JS_CACHE,
    plugins: [
      new ExpirationPlugin({
        // Only cache requests for a week
        maxAgeSeconds: 60, // 7 * 24 * 60 * 60,
        // Only cache 10 requests.
        maxEntries: 10,
      }),
    ],
  })
)

registerRoute(
  ({ request }) => request.mode === 'navigate',
  new CacheFirst({
    // Put all cached files in a cache named 'pages'
    cacheName: 'pages',
    plugins: [
      // Only requests that return with a 200 status are cached
      new CacheableResponsePlugin({
        statuses: [200],
      }),
    ],
  })
)

setCatchHandler(async options => {
  const destination = options.request.destination
  const cache = await self.caches.open(HTML_CACHE)
  if (destination === 'document') {
    return (await cache.match('/offline.html')) || Response.error()
  }
  return Response.error()
})

async function clearCache() {
  const cacheWhitelist = [IMAGE_CACHE, HTML_CACHE, JS_CACHE, MEDIA_CACHE]

  const cacheNames = await caches.keys()
  return await Promise.all(
    cacheNames.map(function (cacheName) {
      if (cacheWhitelist.indexOf(cacheName) === -1) {
        console.log('deleting ' + cacheName)
        return caches.delete(cacheName)
      }
    })
  )
}

self.addEventListener('install', event => {
  event.waitUntil(
    caches.open(HTML_CACHE).then(cache => {
      return cache.addAll(CACHE_URLS)
    })
  )
  self.skipWaiting()
})

self.addEventListener('activate', event => {
  self.clients.claim()
  event.waitUntil(clearCache())
  self.skipWaiting()
})

self.addEventListener('fetch', event => {
  if (
    event.request.url.indexOf('http') > 0 ||
    event?.request?.url?.match('https://firestore.googleapis.com') ||
    event.request.method !== 'GET'
  ) {
    return
  }

  // Skip waiting for this service worker
  event.respondWith(
    caches
      .match(event.request)
      .then(response => {
        if (response) {
          return response
        }

        // Only cache requests with a non-chrome-extension scheme
        if (!event.request.url.startsWith('chrome-extension://')) {
          return fetch(event.request).then(res => {
            return caches.open(CACHE_VERSION).then(cache => {
              cache.put(event.request, res.clone())
              return res
            })
          })
        }

        // Return a 404 response for requests with a chrome-extension scheme
        return new Response('', { status: 404 })
      })
      .then(res => {
        // offline.html is served from cache
        // if (res.url.indexOf('offline.html') > -1) {
        //   return caches.match('/offline.html')
        // }
        return res
      })
  )
})

self.addEventListener('visibilitychange', function () {
  if (document.visibilityState === 'visible') {
    console.log('APP resumed')
    window.location.reload()
  }
})
// This allows the web app to trigger skipWaiting via
// registration.waiting.postMessage({type: 'SKIP_WAITING'})

const skipWaiting = event => {
  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting()
  }
}
self.addEventListener('message', skipWaiting)
